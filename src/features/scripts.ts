import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class ScriptGenerator {
    private _outputChannel: vscode.OutputChannel | undefined;

    constructor(outputChannel?: vscode.OutputChannel) {
        this._outputChannel = outputChannel;
    }

    private log(message: string) {
        if (this._outputChannel) {
            this._outputChannel.appendLine(`[ScriptGenerator] ${message}`);
        }
    }

    public async generateScripts(workspaceUri: vscode.Uri) {
        await this.generateActivationScripts(workspaceUri);
        await this.generateBootstrapScript(workspaceUri);
        vscode.window.showInformationMessage('Activation and Bootstrap scripts generated.');
    }

    public async generateActivationScripts(workspaceUri: vscode.Uri) {
        // Generate activate.sh for bash/zsh (Linux/macOS)
        // Always generate the sh script as it might be useful even on Windows (WSL/Git Bash)
        const shPath = path.join(workspaceUri.fsPath, 'activate.sh');
        if (!fs.existsSync(shPath)) {
            const shContent = `#!/bin/sh
# Activation script generated by Pixi VS Code Extension

# Detect shell
if [ -n "$ZSH_VERSION" ]; then
    _PIXI_SHELL="zsh"
elif [ -n "$BASH_VERSION" ]; then
    _PIXI_SHELL="bash"
else
    _PIXI_SHELL="bash" # Default to bash
fi

if [ -n "$1" ]; then
    _TARGET_ENV="$1"
else
    # Auto-select logic
    _ENVS=$("$PWD/.pixi/bin/pixi" info | grep "Environment:" | awk '{print $2}' | grep -v "^default$")
    _COUNT=$(echo "$_ENVS" | grep -c .)
    
    if [ "$_COUNT" -eq "1" ]; then
        _TARGET_ENV="$_ENVS"
    elif [ -z "$_ENVS" ]; then
        # Only default exists
        _TARGET_ENV=""
    else
        echo "Usage: source activate.sh <environment_name>"
        echo "Available environments:"
        echo "$_ENVS"
        return 1 2>/dev/null || exit 1
    fi
fi

export PATH="$PWD/.pixi/bin:$PATH"
if [ -n "$_TARGET_ENV" ]; then
    eval "$(pixi shell-hook --shell $_PIXI_SHELL -e "$_TARGET_ENV")"
else
    eval "$(pixi shell-hook --shell $_PIXI_SHELL)"
fi
unset _PIXI_SHELL
unset _TARGET_ENV
unset _ENVS
unset _COUNT
`;
            try {
                await fs.promises.writeFile(shPath, shContent, { mode: 0o755 });
                this.log(`Created ${shPath}`);
            } catch (e) {
                console.error(`Failed to create activate.sh: ${e}`);
            }
        }

        // Generate activate.bat for Windows CMD
        // Also useful if user is on Windows
        const batPath = path.join(workspaceUri.fsPath, 'activate.bat');
        if (!fs.existsSync(batPath)) {
            const batContent = `@echo off
rem Activation script generated by Pixi VS Code Extension

set "SCRIPT_DIR=%~dp0"

if not "%~1"=="" (
    set "_TARGET_ENV=%~1"
    goto :activate
)

REM Auto-select logic
set _COUNT=0
set _LAST_ENV=

for /f "tokens=2" %%i in ('call "%SCRIPT_DIR%.pixi\\bin\\pixi" info ^| findstr "Environment:"') do (
    if not "%%i"=="default" (
        set /a _COUNT+=1
        set "_LAST_ENV=%%i"
    )
)

if "%_COUNT%"=="1" (
    set "_TARGET_ENV=%_LAST_ENV%"
    goto :activate
)

if "%_COUNT%"=="0" (
    REM Only default exists
    set "_TARGET_ENV="
    goto :activate
)

echo Usage: activate.bat ^<environment_name^>
echo Available environments:
for /f "tokens=2" %%i in ('call "%SCRIPT_DIR%.pixi\\bin\\pixi" info ^| findstr "Environment:"') do (
     if not "%%i"=="default" echo %%i
)
exit /b 1

:activate
set "PATH=%SCRIPT_DIR%.pixi\\bin;%PATH%"

set "_PARENT_PROC="
set "_PPROC_TMP=%TEMP%\\pixi_pproc_%RANDOM%"

rem Check if running from PowerShell to auto-spawn appropriate shell
powershell -NoProfile -ExecutionPolicy Bypass -Command "$ErrorActionPreference='SilentlyContinue'; $p=Get-CimInstance Win32_Process -Filter \\"ProcessId=$PID\\"; $pp=Get-CimInstance Win32_Process -Filter \\"ProcessId=$($p.ParentProcessId)\\"; $gp=Get-CimInstance Win32_Process -Filter \\"ProcessId=$($pp.ParentProcessId)\\"; if ($gp.Name -match 'pwsh') {Write-Host 'pwsh'} elseif ($gp.Name -match 'powershell') {Write-Host 'powershell'}" > "%_PPROC_TMP%"
set /p _PARENT_PROC=<"%_PPROC_TMP%"
del "%_PPROC_TMP%" 2>nul
set "_PPROC_TMP="



if not "%_PARENT_PROC%"=="" goto :activate_powershell

:activate_cmd
set "_TEMP_SCRIPT=%TEMP%\\pixi_env_%RANDOM%.bat"

if not "%_TARGET_ENV%"=="" (
    call pixi shell-hook --shell cmd -e "%_TARGET_ENV%" > "%_TEMP_SCRIPT%"
) else (
    call pixi shell-hook --shell cmd > "%_TEMP_SCRIPT%"
)

if exist "%_TEMP_SCRIPT%" (
    call "%_TEMP_SCRIPT%"
    del "%_TEMP_SCRIPT%"
)

call :cleanup_vars
set "_PARENT_PROC="
exit /b

:activate_powershell

set "_PS_TEMP_SCRIPT=%TEMP%\\pixi_env_%RANDOM%.ps1"

if not "%_TARGET_ENV%"=="" (
    call pixi shell-hook --shell powershell -e "%_TARGET_ENV%" > "%_PS_TEMP_SCRIPT%"
) else (
    call pixi shell-hook --shell powershell > "%_PS_TEMP_SCRIPT%"
)

call :cleanup_vars

rem Spawn nested shell
call %_PARENT_PROC% -NoExit -ExecutionPolicy Bypass -File "%_PS_TEMP_SCRIPT%"

del "%_PS_TEMP_SCRIPT%"
set "_PARENT_PROC="
exit /b

:cleanup_vars
set "_TARGET_ENV="
set "_COUNT="
set "_LAST_ENV="
set "_TEMP_SCRIPT="
set "SCRIPT_DIR="
exit /b
`;
            try {
                await fs.promises.writeFile(batPath, batContent);
                this.log(`Created ${batPath}`);
            } catch (e) {
                console.error(`Failed to create activate.bat: ${e}`);
            }
        }
    }

    public async generateBootstrapScript(workspaceUri: vscode.Uri) {
        // Linux/macOS bootstrap.sh
        const shPath = path.join(workspaceUri.fsPath, 'bootstrap.sh');
        if (!fs.existsSync(shPath)) {
            const shContent = `#!/bin/bash
# Bootstrap script generated by Pixi VS Code Extension
# Downloads Pixi if missing and activates the environment

# Safe exit function (handles sourcing vs execution)
die() {
    echo "$1"
    # Check if sourced (Zsh vs Bash)
    if [[ -n "$ZSH_VERSION" ]]; then
       if [[ -o interactive ]]; then return 1; else exit 1; fi
    elif [[ "\${BASH_SOURCE[0]}" != "\${0}" ]]; then
        return 1
    else
        exit 1
    fi
}

# 1. Check for Pixi
if ! command -v pixi &> /dev/null; then
    if [ ! -f ".pixi/bin/pixi" ]; then
        echo "Pixi not found. Installing..."
        mkdir -p .pixi/bin
        
        # Detect OS/Arch
        OS="$(uname -s)"
        ARCH="$(uname -m)"
        
        URL=""
        if [ "$OS" = "Linux" ] && [ "$ARCH" = "x86_64" ]; then
            URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-x86_64-unknown-linux-musl.tar.gz"
        elif [ "$OS" = "Darwin" ] && [ "$ARCH" = "arm64" ]; then
            URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-aarch64-apple-darwin.tar.gz"
        elif [ "$OS" = "Darwin" ] && [ "$ARCH" = "x86_64" ]; then
             URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-x86_64-apple-darwin.tar.gz"
        else
            die "Unsupported platform for auto-bootstrap: $OS $ARCH"
        fi
        
        echo "Downloading $URL..."
        curl -L "$URL" -o pixi.tar.gz
        tar -xzf pixi.tar.gz -C .pixi/bin
        rm pixi.tar.gz
        chmod +x .pixi/bin/pixi
        echo "Pixi installed to .pixi/bin/pixi"
    fi
    export PATH="$PWD/.pixi/bin:$PATH"
fi

# 2. Activate
echo "Activating SPARK Environment..."
if [ -f "activate.sh" ]; then
    source activate.sh
else
    eval "$(pixi shell-hook)"
fi
`;
            try {
                await fs.promises.writeFile(shPath, shContent, { mode: 0o755 });
                this.log(`Created ${shPath}`);
            } catch (e) {
                console.error(`Failed to create bootstrap.sh: ${e}`);
            }
        }

        // Windows bootstrap.bat (Calls PowerShell for download)
        const batPath = path.join(workspaceUri.fsPath, 'bootstrap.bat');
        if (!fs.existsSync(batPath)) {
            const batContent = `@echo off
setlocal EnableDelayedExpansion

REM Bootstrap script generated by Pixi VS Code Extension

set "BASE_URL=https://github.com/prefix-dev/pixi/releases/latest/download"
set "SCRIPT_DIR=%~dp0"
set "PIXI_DIR=%SCRIPT_DIR%.pixi\\bin"
set "PIXI_BIN=%PIXI_DIR%\\pixi.exe"
set "TARGET=x86_64-pc-windows-msvc"
set "ZIP_FILE=%SCRIPT_DIR%pixi.zip"

if not exist "%PIXI_BIN%" (
    echo Pixi not found.
    if not exist "%PIXI_DIR%" mkdir "%PIXI_DIR%"

    echo Downloading %BASE_URL%/pixi-%TARGET%.zip ...
    powershell -NoProfile -Command "$ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri '%BASE_URL%/pixi-%TARGET%.zip' -OutFile '%ZIP_FILE%'"
    
    if exist "%ZIP_FILE%" (
        echo Extracting...
        powershell -NoProfile -Command "Expand-Archive -Path '%ZIP_FILE%' -DestinationPath '%PIXI_DIR%' -Force"
        del "%ZIP_FILE%"
    ) else (
        echo Failed to download pixi.zip
        exit /b 1
    )
    
    if not exist "%PIXI_BIN%" (
        echo Checking for nested pixi.exe...
        for /r "%PIXI_DIR%" %%F in (pixi.exe) do (
            move /y "%%F" "%PIXI_BIN%"
        )
    )

    if not exist "%PIXI_BIN%" (
        echo Error: pixi.exe still not found.
        exit /b 1
    )
    
    echo Pixi installed.
)

endlocal

if exist "%SCRIPT_DIR%activate.bat" (
    call "%SCRIPT_DIR%activate.bat" %*
) else (
    echo activate.bat not found.
    exit /b 1
)
`;
            try {
                await fs.promises.writeFile(batPath, batContent);
                this.log(`Created ${batPath}`);
            } catch (e) {
                console.error(`Failed to create bootstrap.bat: ${e}`);
            }
        }
    }
}
