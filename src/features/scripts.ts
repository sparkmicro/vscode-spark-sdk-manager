import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class ScriptGenerator {
    private _outputChannel: vscode.OutputChannel | undefined;

    constructor(outputChannel?: vscode.OutputChannel) {
        this._outputChannel = outputChannel;
    }

    private log(message: string) {
        if (this._outputChannel) {
            this._outputChannel.appendLine(`[ScriptGenerator] ${message}`);
        }
    }

    public async generateScripts(workspaceUri: vscode.Uri) {
        await this.generateActivationScripts(workspaceUri);
        await this.generateBootstrapScript(workspaceUri);
        vscode.window.showInformationMessage('Activation and Bootstrap scripts generated.');
    }

    public async generateActivationScripts(workspaceUri: vscode.Uri) {
        // Generate activate.sh for bash/zsh (Linux/macOS)
        // Always generate the sh script as it might be useful even on Windows (WSL/Git Bash)
        const shPath = path.join(workspaceUri.fsPath, 'activate.sh');
        if (!fs.existsSync(shPath)) {
            const shContent = `#!/bin/sh
# Activation script generated by Pixi VS Code Extension

# Detect shell
if [ -n "$ZSH_VERSION" ]; then
    _PIXI_SHELL="zsh"
elif [ -n "$BASH_VERSION" ]; then
    _PIXI_SHELL="bash"
else
    _PIXI_SHELL="bash" # Default to bash
fi

if [ -n "$1" ]; then
    _TARGET_ENV="$1"
else
    # Auto-select logic
    _ENVS=$("$PWD/.pixi/bin/pixi" info | grep "Environment:" | awk '{print $2}' | grep -v "^default$")
    _COUNT=$(echo "$_ENVS" | grep -c .)
    
    if [ "$_COUNT" -eq "1" ]; then
        _TARGET_ENV="$_ENVS"
    elif [ -z "$_ENVS" ]; then
        # Only default exists
        _TARGET_ENV=""
    else
        echo "Usage: source activate.sh <environment_name>"
        echo "Available environments:"
        echo "$_ENVS"
        return 1 2>/dev/null || exit 1
    fi
fi

export PATH="$PWD/.pixi/bin:$PATH"
if [ -n "$_TARGET_ENV" ]; then
    eval "$(pixi shell-hook --shell $_PIXI_SHELL -e "$_TARGET_ENV")"
else
    eval "$(pixi shell-hook --shell $_PIXI_SHELL)"
fi
unset _PIXI_SHELL
unset _TARGET_ENV
unset _ENVS
unset _COUNT
`;
            try {
                await fs.promises.writeFile(shPath, shContent, { mode: 0o755 });
                this.log(`Created ${shPath}`);
            } catch (e) {
                console.error(`Failed to create activate.sh: ${e}`);
            }
        }

        // Generate activate.bat for Windows CMD
        // Also useful if user is on Windows
        const batPath = path.join(workspaceUri.fsPath, 'activate.bat');
        if (!fs.existsSync(batPath)) {
            const batContent = `@echo off
rem Activation script generated by Pixi VS Code Extension

set "SCRIPT_DIR=%~dp0"

if not "%~1"=="" (
    set "_TARGET_ENV=%~1"
    goto :activate
)

REM Auto-select logic
set _COUNT=0
set _LAST_ENV=

for /f "tokens=2" %%i in ('call "%SCRIPT_DIR%.pixi\\bin\\pixi" info ^| findstr "Environment:"') do (
    if not "%%i"=="default" (
        set /a _COUNT+=1
        set "_LAST_ENV=%%i"
    )
)

if "%_COUNT%"=="1" (
    set "_TARGET_ENV=%_LAST_ENV%"
    goto :activate
)

if "%_COUNT%"=="0" (
    REM Only default exists
    set "_TARGET_ENV="
    goto :activate
)

echo Usage: activate.bat ^<environment_name^>
echo Available environments:
for /f "tokens=2" %%i in ('call "%SCRIPT_DIR%.pixi\\bin\\pixi" info ^| findstr "Environment:"') do (
     if not "%%i"=="default" echo %%i
)
exit /b 1

:activate
set "PATH=%SCRIPT_DIR%.pixi\\bin;%PATH%"

set "_TEMP_SCRIPT=%TEMP%\\pixi_env_%RANDOM%.bat"

if not "%_TARGET_ENV%"=="" (
    call pixi shell-hook --shell cmd -e "%_TARGET_ENV%" > "%_TEMP_SCRIPT%"
) else (
    call pixi shell-hook --shell cmd > "%_TEMP_SCRIPT%"
)

if exist "%_TEMP_SCRIPT%" (
    call "%_TEMP_SCRIPT%"
    del "%_TEMP_SCRIPT%"
)

set "_TARGET_ENV="
set "_COUNT="
set "_LAST_ENV="
set "_TEMP_SCRIPT="
set "SCRIPT_DIR="
`;
            try {
                await fs.promises.writeFile(batPath, batContent);
                this.log(`Created ${batPath}`);
            } catch (e) {
                console.error(`Failed to create activate.bat: ${e}`);
            }
        }
    }

    public async generateBootstrapScript(workspaceUri: vscode.Uri) {
        // Linux/macOS bootstrap.sh
        const shPath = path.join(workspaceUri.fsPath, 'bootstrap.sh');
        if (!fs.existsSync(shPath)) {
            const shContent = `#!/bin/bash
# Bootstrap script generated by Pixi VS Code Extension
# Downloads Pixi if missing and activates the environment

# Safe exit function (handles sourcing vs execution)
die() {
    echo "$1"
    # Check if sourced (Zsh vs Bash)
    if [[ -n "$ZSH_VERSION" ]]; then
       if [[ -o interactive ]]; then return 1; else exit 1; fi
    elif [[ "\${BASH_SOURCE[0]}" != "\${0}" ]]; then
        return 1
    else
        exit 1
    fi
}

# 1. Check for Pixi
if ! command -v pixi &> /dev/null; then
    if [ ! -f ".pixi/bin/pixi" ]; then
        echo "Pixi not found. Installing..."
        mkdir -p .pixi/bin
        
        # Detect OS/Arch
        OS="$(uname -s)"
        ARCH="$(uname -m)"
        
        URL=""
        if [ "$OS" = "Linux" ] && [ "$ARCH" = "x86_64" ]; then
            URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-x86_64-unknown-linux-musl.tar.gz"
        elif [ "$OS" = "Darwin" ] && [ "$ARCH" = "arm64" ]; then
            URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-aarch64-apple-darwin.tar.gz"
        elif [ "$OS" = "Darwin" ] && [ "$ARCH" = "x86_64" ]; then
             URL="https://github.com/prefix-dev/pixi/releases/latest/download/pixi-x86_64-apple-darwin.tar.gz"
        else
            die "Unsupported platform for auto-bootstrap: $OS $ARCH"
        fi
        
        echo "Downloading $URL..."
        curl -L "$URL" -o pixi.tar.gz
        tar -xzf pixi.tar.gz -C .pixi/bin
        rm pixi.tar.gz
        chmod +x .pixi/bin/pixi
        echo "Pixi installed to .pixi/bin/pixi"
    fi
    export PATH="$PWD/.pixi/bin:$PATH"
fi

# 2. Activate
echo "Activating SPARK Environment..."
if [ -f "activate.sh" ]; then
    source activate.sh
else
    eval "$(pixi shell-hook)"
fi
`;
            try {
                await fs.promises.writeFile(shPath, shContent, { mode: 0o755 });
                this.log(`Created ${shPath}`);
            } catch (e) {
                console.error(`Failed to create bootstrap.sh: ${e}`);
            }
        }
    }
}
